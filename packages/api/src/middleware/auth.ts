import type { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { randomUUID } from 'crypto';
import { UnauthorizedError } from '../utils/errors.js';
import { logger } from '../utils/logger.js';

export interface JWTPayload {
  sub: string;        // User UUID
  device_id: string;  // Device UUID
  iat: number;        // Issued at
  exp: number;        // Expires at
  jti: string;        // JWT ID (for revocation)
}

export interface TokenInput {
  sub: string;
  device_id: string;
}

export interface AuthenticatedRequest extends Request {
  user: {
    id: string;
    deviceId: string;
    jti: string;
  };
}

/**
 * Validate and get JWT secret from environment
 * @throws {Error} If JWT_SECRET is not set or too weak
 */
function getJwtSecret(): string {
  const secret = process.env.JWT_SECRET;
  if (!secret) {
    throw new Error('JWT_SECRET environment variable is not set');
  }

  // Validate secret strength (at least 32 characters for security)
  if (secret.length < 32) {
    throw new Error(
      'JWT_SECRET must be at least 32 characters long. ' +
      'Current length: ' + secret.length + '. ' +
      'Use: openssl rand -base64 48'
    );
  }

  // Warn if using default/dev secret
  if (secret === 'your-secret-key-change-in-production' ||
      secret === 'secret' ||
      secret === 'jwt-secret') {
    console.warn('⚠️  WARNING: Using default/insecure JWT secret!');
  }

  return secret;
}

export function generateAccessToken(payload: TokenInput): string {
  const secret = getJwtSecret();
  const expiresIn = process.env.JWT_ACCESS_EXPIRY || '7d';

  return jwt.sign(payload, secret, {
    expiresIn,
    jwtid: randomUUID(), // jti is generated by the library
  } as jwt.SignOptions);
}

export function generateRefreshToken(payload: TokenInput): string {
  const secret = getJwtSecret();
  const expiresIn = process.env.JWT_REFRESH_EXPIRY || '30d';

  return jwt.sign(payload, secret, {
    expiresIn,
    jwtid: randomUUID(), // jti is generated by the library
  } as jwt.SignOptions);
}

export function verifyToken(token: string): JWTPayload {
  const secret = getJwtSecret();

  try {
    return jwt.verify(token, secret) as JWTPayload;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new UnauthorizedError('Token has expired');
    } else if (error instanceof jwt.JsonWebTokenError) {
      throw new UnauthorizedError('Invalid token');
    } else {
      throw new UnauthorizedError('Token verification failed');
    }
  }
}

export function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  try {
    // Extract token from Authorization header
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedError('Missing or invalid Authorization header');
    }

    const token = authHeader.substring(7); // Remove 'Bearer ' prefix

    if (!token) {
      throw new UnauthorizedError('No token provided');
    }

    // Verify token
    const payload = verifyToken(token);

    // Attach user info to request
    (req as AuthenticatedRequest).user = {
      id: payload.sub,
      deviceId: payload.device_id,
      jti: payload.jti,
    };

    next();
  } catch (error) {
    if (error instanceof UnauthorizedError) {
      logger.warn({
        error: error.message,
        path: req.path,
        method: req.method,
        ip: req.ip,
      }, 'Authentication failed');

      res.status(401).json({
        error: 'unauthorized',
        message: error.message,
      });
    } else {
      logger.error({
        err: error,
        path: req.path,
        method: req.method,
      }, 'Unexpected authentication error');

      res.status(500).json({
        error: 'internal_error',
        message: 'An unexpected error occurred',
      });
    }
  }
}

export function optionalAuthMiddleware(
  req: Request,
  _res: Response,
  next: NextFunction
): void {
  try {
    const authHeader = req.headers.authorization;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);

      if (token) {
        const payload = verifyToken(token);
        (req as AuthenticatedRequest).user = {
          id: payload.sub,
          deviceId: payload.device_id,
          jti: payload.jti,
        };
      }
    }

    next();
  } catch (error) {
    // For optional auth, we don't reject on invalid tokens
    // Just don't attach user info
    next();
  }
}
